# III. 소프트웨어 설계서

## 1. 개요

본 장에서는 DoctorLink 플랫폼의 소프트웨어 설계 내용을 상세히 기술한다. 시스템 아키텍처, 데이터베이스 설계, API 설계, UI/UX 설계를 포함하며, 각 설계는 확장성, 유지보수성, 보안성을 고려하여 수립되었다.

### 1.1 설계 원칙

**확장성 (Scalability)**
- 수평적 확장 가능한 아키텍처
- 마이크로서비스 전환 가능한 모듈화 구조
- 캐싱 전략을 통한 성능 최적화

**유지보수성 (Maintainability)**
- 계층형 아키텍처로 관심사 분리
- 재사용 가능한 컴포넌트 설계
- 명확한 명명 규칙 및 코드 컨벤션

**보안성 (Security)**
- JWT 토큰 기반 인증
- HTTPS 통신 강제
- SQL Injection, XSS 공격 방어
- 민감한 정보 암호화 저장

**사용성 (Usability)**
- 직관적인 UI/UX
- 접근성 (Accessibility) 고려
- 반응형 디자인

## 2. 설계 내용

### 2.1 시스템 아키텍처

#### 2.1.1 전체 시스템 구성도

```
┌──────────────────────────────────────────────────────────┐
│                     클라이언트 계층                        │
├─────────────────┬────────────────┬──────────────────────┤
│   웹 브라우저    │  Android 앱     │    iOS 앱            │
│   (React SPA)   │ (React Native) │  (React Native)      │
│   - Chrome      │  - Android 10+  │   - iOS 13+         │
│   - Firefox     │                 │                      │
│   - Safari      │                 │                      │
└─────────────────┴────────────────┴──────────────────────┘
           │                │                │
           └────────────────┼────────────────┘
                            │
                    HTTPS / REST API
                            │
┌───────────────────────────▼───────────────────────────────┐
│                    애플리케이션 계층                        │
│  ┌────────────────────────────────────────────────────┐  │
│  │          API Gateway / Load Balancer               │  │
│  │          (Nginx - 향후 도입 예정)                  │  │
│  └────────────────────────────────────────────────────┘  │
│                            │                              │
│  ┌────────────────────────▼────────────────────────┐     │
│  │            Node.js / Express.js Server          │     │
│  │                (Port: 3000/5000)                │     │
│  ├─────────────────────────────────────────────────┤     │
│  │  Routes Layer (라우팅)                          │     │
│  │  - /api/auth      - /api/hospitals             │     │
│  │  - /api/users     - /api/appointments          │     │
│  │  - /api/medical-records                        │     │
│  ├─────────────────────────────────────────────────┤     │
│  │  Middleware (미들웨어)                          │     │
│  │  - JWT Authentication                          │     │
│  │  - Error Handler                               │     │
│  │  - Request Logger                              │     │
│  │  - CORS Handler                                │     │
│  ├─────────────────────────────────────────────────┤     │
│  │  Controllers (컨트롤러)                         │     │
│  │  - authController.ts                           │     │
│  │  - hospitalController.ts                       │     │
│  │  - appointmentController.ts                    │     │
│  ├─────────────────────────────────────────────────┤     │
│  │  Services (비즈니스 로직)                       │     │
│  │  - authService.ts                              │     │
│  │  - hospitalService.ts                          │     │
│  │  - appointmentService.ts                       │     │
│  ├─────────────────────────────────────────────────┤     │
│  │  Models (데이터 모델)                           │     │
│  │  - User, Hospital, Appointment                 │     │
│  │  - Doctor, MedicalRecord                       │     │
│  └─────────────────────────────────────────────────┘     │
└───────────────────────────┬───────────────────────────────┘
                            │
                    SQL Queries (TCP/IP)
                            │
┌───────────────────────────▼───────────────────────────────┐
│                      데이터 계층                           │
│  ┌────────────────────────────────────────────────────┐  │
│  │       Microsoft SQL Server 2019                    │  │
│  │              (Port: 1433)                          │  │
│  ├────────────────────────────────────────────────────┤  │
│  │  Database: DoctorLink                             │  │
│  │  ┌──────────────────────────────────────────────┐ │  │
│  │  │  Tables:                                     │ │  │
│  │  │  - Users                                     │ │  │
│  │  │  - Hospitals                                 │ │  │
│  │  │  - Doctors                                   │ │  │
│  │  │  - Appointments                              │ │  │
│  │  │  - MedicalRecords                            │ │  │
│  │  │  - Reviews                                   │ │  │
│  │  │  - Notifications                             │ │  │
│  │  │  - Inquiries                                 │ │  │
│  │  └──────────────────────────────────────────────┘ │  │
│  │  ┌──────────────────────────────────────────────┐ │  │
│  │  │  Stored Procedures:                          │ │  │
│  │  │  - sp_GetAvailableTimeSlots                  │ │  │
│  │  │  - sp_CreateAppointment                      │ │  │
│  │  │  - sp_UpdateAppointmentStatus                │ │  │
│  │  └──────────────────────────────────────────────┘ │  │
│  └────────────────────────────────────────────────────┘  │
└───────────────────────────────────────────────────────────┘

┌───────────────────────────────────────────────────────────┐
│                    외부 서비스 계층                        │
├─────────────────┬────────────────┬──────────────────────┤
│  카카오맵 API    │  FCM (푸시알림)  │   SMTP (이메일)      │
│  (지도/길찾기)   │  (예정)         │   (예정)             │
└─────────────────┴────────────────┴──────────────────────┘
```

#### 2.1.2 3-Tier 아키텍처

**Presentation Tier (표현 계층)**
- **역할**: 사용자 인터페이스 제공, 사용자 입력 처리
- **구성**: React (웹), React Native (모바일)
- **책임**:
  - 사용자 입력 수집 및 검증
  - API 호출을 통한 데이터 요청
  - 응답 데이터의 시각화
  - 상태 관리 (Context API)

**Application Tier (애플리케이션 계층)**
- **역할**: 비즈니스 로직 처리, API 제공
- **구성**: Node.js + Express.js
- **책임**:
  - RESTful API 엔드포인트 제공
  - 인증/인가 처리
  - 비즈니스 규칙 적용
  - 데이터 검증 및 변환
  - 에러 처리

**Data Tier (데이터 계층)**
- **역할**: 데이터 저장 및 관리
- **구성**: Microsoft SQL Server
- **책임**:
  - 영구 데이터 저장
  - 트랜잭션 관리
  - 데이터 무결성 보장
  - 쿼리 최적화

#### 2.1.3 웹 애플리케이션 아키텍처

```
React SPA (Single Page Application)
├── src/
│   ├── pages/               # 페이지 컴포넌트
│   │   ├── HomePage.tsx
│   │   ├── LoginPage.tsx
│   │   └── ...
│   │
│   ├── components/          # 재사용 컴포넌트
│   │   ├── common/
│   │   │   ├── Button.tsx
│   │   │   ├── Input.tsx
│   │   │   └── Modal.tsx
│   │   └── layout/
│   │       ├── Header.tsx
│   │       └── Footer.tsx
│   │
│   ├── context/             # 전역 상태 관리
│   │   └── AuthContext.tsx
│   │
│   ├── services/            # API 서비스
│   │   ├── api.ts           # Axios 인스턴스
│   │   ├── authService.ts
│   │   └── hospitalService.ts
│   │
│   ├── hooks/               # 커스텀 훅
│   │   └── useAuth.ts
│   │
│   ├── types/               # TypeScript 타입
│   │   └── index.ts
│   │
│   └── utils/               # 유틸리티 함수
│       └── validation.ts

데이터 흐름:
User Action → Component → Service → API → Server → Database
                ↓                                      ↓
            Context ← ← ← ← ← ← Response ← ← ← ← ← ←
```

#### 2.1.4 모바일 애플리케이션 아키텍처

```
React Native App
├── src/
│   ├── screens/             # 화면 컴포넌트
│   │   ├── auth/
│   │   ├── main/
│   │   ├── hospital/
│   │   └── ...
│   │
│   ├── navigation/          # 네비게이션
│   │   └── AppNavigator.tsx
│   │
│   ├── contexts/            # Context API
│   │   └── AuthContext.tsx
│   │
│   ├── services/            # API 서비스
│   │   ├── api.ts
│   │   └── authService.ts
│   │
│   └── components/          # 공통 컴포넌트
│       └── common/

네비게이션 구조:
AuthStack (인증 전)
├── LoginScreen
└── RegisterScreen

MainStack (인증 후)
├── TabNavigator
│   ├── HomeScreen
│   ├── HospitalFinderScreen
│   ├── ReservationManagementScreen
│   ├── MedicalRecordsScreen
│   └── MyPageScreen
└── Stack Screens
    ├── HospitalDetailScreen
    ├── ReservationScreen
    └── ...
```

#### 2.1.5 백엔드 아키텍처 (계층형)

```
Express.js Server

┌─────────────────────────────────────────┐
│        Routes (라우터 계층)              │
│  - 요청 URL 매핑                         │
│  - HTTP 메서드 정의                      │
│  - 미들웨어 연결                         │
└────────────┬────────────────────────────┘
             │
┌────────────▼────────────────────────────┐
│      Controllers (컨트롤러 계층)         │
│  - 요청/응답 처리                        │
│  - 입력 검증                             │
│  - 서비스 호출                           │
│  - HTTP 상태 코드 설정                   │
└────────────┬────────────────────────────┘
             │
┌────────────▼────────────────────────────┐
│       Services (서비스 계층)             │
│  - 비즈니스 로직                         │
│  - 트랜잭션 관리                         │
│  - 여러 모델 조합                        │
│  - 외부 API 호출                         │
└────────────┬────────────────────────────┘
             │
┌────────────▼────────────────────────────┐
│        Models (모델 계층)                │
│  - 데이터베이스 쿼리                     │
│  - CRUD 연산                             │
│  - 데이터 매핑                           │
└─────────────────────────────────────────┘
```

**예시: 예약 생성 흐름**

```typescript
// 1. Route
router.post('/appointments', authenticateJWT, appointmentController.create);

// 2. Controller
async create(req, res) {
  try {
    const appointmentData = req.body;
    const userId = req.user.userId;
    
    // 서비스 호출
    const appointment = await appointmentService.createAppointment(userId, appointmentData);
    
    res.status(201).json({ success: true, data: appointment });
  } catch (error) {
    res.status(400).json({ success: false, message: error.message });
  }
}

// 3. Service
async createAppointment(userId, data) {
  // 비즈니스 로직
  // 1. 시간 중복 확인
  const isAvailable = await this.checkAvailability(data.doctorId, data.date, data.time);
  if (!isAvailable) throw new Error('이미 예약된 시간입니다.');
  
  // 2. 트랜잭션 시작
  const appointment = await Appointment.create({
    patientId: userId,
    ...data
  });
  
  // 3. 알림 전송
  await notificationService.sendAppointmentNotification(appointment);
  
  return appointment;
}

// 4. Model
class Appointment {
  static async create(data) {
    const query = `
      INSERT INTO Appointments (PatientID, DoctorID, AppointmentDate, AppointmentTime, Reason)
      VALUES (?, ?, ?, ?, ?)
    `;
    const result = await db.query(query, [data.patientId, data.doctorId, ...]);
    return result;
  }
}
```

### 2.2 데이터베이스 설계

#### 2.2.1 ERD (Entity Relationship Diagram)

```
┌─────────────────┐
│     Users       │
├─────────────────┤
│ UserID (PK)     │◄──────┐
│ Email           │       │
│ Password        │       │
│ Name            │       │
│ Phone           │       │
│ Role            │       │
│ BirthDate       │       │
│ Gender          │       │
│ CreatedAt       │       │
└─────────────────┘       │
        │                 │
        │ 1               │ 1
        │                 │
        │ *               │ *
┌───────▼──────────┐  ┌───▼──────────────┐
│  Appointments    │  │  MedicalRecords  │
├──────────────────┤  ├──────────────────┤
│ AppointmentID(PK)│  │ RecordID (PK)    │
│ PatientID (FK)   │  │ PatientID (FK)   │
│ DoctorID (FK)    │──┤ DoctorID (FK)    │
│ AppointmentDate  │  │ AppointmentID(FK)│
│ AppointmentTime  │  │ Diagnosis        │
│ Status           │  │ Treatment        │
│ Reason           │  │ Prescription     │
│ CreatedAt        │  │ Notes            │
└──────────────────┘  │ RecordDate       │
        │             └──────────────────┘
        │ *
        │
        │ 1
┌───────▼──────────┐
│     Doctors      │
├──────────────────┤
│ DoctorID (PK)    │◄──────┐
│ UserID (FK)      │       │
│ HospitalID (FK)  │───┐   │
│ Specialty        │   │   │
│ LicenseNumber    │   │   │
│ Experience       │   │   │
│ Bio              │   │   │
└──────────────────┘   │   │
                       │   │ *
                       │   │
                    1  │   │ 1
┌──────────────────┐   │ ┌─▼──────────────┐
│    Hospitals     │   │ │    Reviews     │
├──────────────────┤   │ ├────────────────┤
│ HospitalID (PK)  │◄──┘ │ ReviewID (PK)  │
│ Name             │     │ PatientID (FK) │
│ Address          │     │ DoctorID (FK)  │
│ City             │     │ Rating         │
│ Type             │     │ Comment        │
│ Phone            │     │ CreatedAt      │
│ Latitude         │     └────────────────┘
│ Longitude        │
│ Rating           │
│ CreatedAt        │
└──────────────────┘
        │ 1
        │
        │ *
┌───────▼──────────┐
│  Notifications   │
├──────────────────┤
│ NotificationID(PK)│
│ UserID (FK)      │
│ Type             │
│ Title            │
│ Message          │
│ IsRead           │
│ CreatedAt        │
└──────────────────┘
```

#### 2.2.2 테이블 상세 설계

**Users (사용자 테이블)**

| 컬럼명 | 데이터 타입 | NULL | 키 | 기본값 | 설명 |
|--------|------------|------|-----|--------|------|
| UserID | INT | NO | PK | IDENTITY | 사용자 고유 ID |
| Email | NVARCHAR(100) | NO | UNIQUE | | 이메일 (로그인용) |
| Password | NVARCHAR(255) | NO | | | bcrypt 해시 비밀번호 |
| Name | NVARCHAR(50) | NO | | | 이름 |
| Phone | NVARCHAR(20) | YES | | | 전화번호 |
| Role | NVARCHAR(20) | NO | | 'patient' | 역할 (patient/doctor/admin) |
| BirthDate | DATE | YES | | | 생년월일 |
| Gender | NVARCHAR(10) | YES | | | 성별 (male/female) |
| Address | NVARCHAR(255) | YES | | | 주소 |
| BloodType | NVARCHAR(5) | YES | | | 혈액형 |
| Allergies | NVARCHAR(255) | YES | | | 알레르기 (JSON 배열) |
| CreatedAt | DATETIME | NO | | GETDATE() | 가입 일시 |
| UpdatedAt | DATETIME | YES | | | 수정 일시 |

**Hospitals (병원 테이블)**

| 컬럼명 | 데이터 타입 | NULL | 키 | 기본값 | 설명 |
|--------|------------|------|-----|--------|------|
| HospitalID | INT | NO | PK | IDENTITY | 병원 고유 ID |
| Name | NVARCHAR(100) | NO | | | 병원명 |
| Address | NVARCHAR(255) | NO | | | 주소 |
| City | NVARCHAR(50) | NO | INDEX | | 시/도 |
| District | NVARCHAR(50) | YES | | | 구/군 |
| Type | NVARCHAR(50) | NO | | | 병원 유형 (종합병원 등) |
| Phone | NVARCHAR(20) | NO | | | 대표 전화번호 |
| Latitude | DECIMAL(10,8) | YES | | | 위도 |
| Longitude | DECIMAL(11,8) | YES | | | 경도 |
| Rating | DECIMAL(3,2) | YES | | 0.00 | 평균 평점 (0.00~5.00) |
| ReviewCount | INT | NO | | 0 | 리뷰 수 |
| Description | NVARCHAR(500) | YES | | | 병원 소개 |
| OpenTime | TIME | YES | | | 개원 시간 |
| CloseTime | TIME | YES | | | 폐원 시간 |
| CreatedAt | DATETIME | NO | | GETDATE() | 등록 일시 |

**Doctors (의사 테이블)**

| 컬럼명 | 데이터 타입 | NULL | 키 | 기본값 | 설명 |
|--------|------------|------|-----|--------|------|
| DoctorID | INT | NO | PK | IDENTITY | 의사 고유 ID |
| UserID | INT | NO | FK | | Users.UserID |
| HospitalID | INT | NO | FK | | Hospitals.HospitalID |
| Specialty | NVARCHAR(50) | NO | | | 전문 분야 (내과, 외과 등) |
| LicenseNumber | NVARCHAR(50) | NO | UNIQUE | | 의사 면허 번호 |
| Experience | INT | YES | | | 경력 (년) |
| Education | NVARCHAR(255) | YES | | | 학력 |
| Bio | NVARCHAR(500) | YES | | | 소개 |
| ProfileImage | NVARCHAR(255) | YES | | | 프로필 사진 URL |
| CreatedAt | DATETIME | NO | | GETDATE() | 등록 일시 |

**Appointments (예약 테이블)**

| 컬럼명 | 데이터 타입 | NULL | 키 | 기본값 | 설명 |
|--------|------------|------|-----|--------|------|
| AppointmentID | INT | NO | PK | IDENTITY | 예약 고유 ID |
| PatientID | INT | NO | FK | | Users.UserID |
| DoctorID | INT | NO | FK, INDEX | | Doctors.DoctorID |
| AppointmentDate | DATE | NO | INDEX | | 예약 날짜 |
| AppointmentTime | TIME | NO | | | 예약 시간 |
| Status | NVARCHAR(20) | NO | INDEX | 'pending' | 상태 (pending/approved/completed/cancelled) |
| Reason | NVARCHAR(255) | YES | | | 방문 사유 |
| Notes | NVARCHAR(500) | YES | | | 추가 메모 |
| CreatedAt | DATETIME | NO | | GETDATE() | 예약 생성 일시 |
| UpdatedAt | DATETIME | YES | | | 수정 일시 |

**복합 인덱스**: `(DoctorID, AppointmentDate, AppointmentTime)` - 중복 예약 방지 및 검색 성능 향상

**MedicalRecords (진료 기록 테이블)**

| 컬럼명 | 데이터 타입 | NULL | 키 | 기본값 | 설명 |
|--------|------------|------|-----|--------|------|
| RecordID | INT | NO | PK | IDENTITY | 기록 고유 ID |
| PatientID | INT | NO | FK, INDEX | | Users.UserID |
| DoctorID | INT | NO | FK | | Doctors.DoctorID |
| AppointmentID | INT | YES | FK | | Appointments.AppointmentID |
| Diagnosis | NVARCHAR(255) | NO | | | 진단명 |
| Treatment | NVARCHAR(500) | YES | | | 치료 내용 |
| Prescription | NVARCHAR(500) | YES | | | 처방전 |
| Notes | NVARCHAR(1000) | YES | | | 진료 메모 |
| Attachments | NVARCHAR(MAX) | YES | | | 첨부파일 (JSON 배열) |
| RecordDate | DATE | NO | | GETDATE() | 진료 날짜 |
| CreatedAt | DATETIME | NO | | GETDATE() | 기록 생성 일시 |

**Reviews (리뷰 테이블)**

| 컬럼명 | 데이터 타입 | NULL | 키 | 기본값 | 설명 |
|--------|------------|------|-----|--------|------|
| ReviewID | INT | NO | PK | IDENTITY | 리뷰 고유 ID |
| PatientID | INT | NO | FK | | Users.UserID |
| DoctorID | INT | NO | FK, INDEX | | Doctors.DoctorID |
| HospitalID | INT | NO | FK, INDEX | | Hospitals.HospitalID |
| AppointmentID | INT | YES | FK, UNIQUE | | Appointments.AppointmentID |
| Rating | INT | NO | | | 평점 (1~5) |
| Comment | NVARCHAR(500) | YES | | | 리뷰 내용 |
| CreatedAt | DATETIME | NO | | GETDATE() | 작성 일시 |

**CHECK 제약조건**: `Rating BETWEEN 1 AND 5`

**Notifications (알림 테이블)**

| 컬럼명 | 데이터 타입 | NULL | 키 | 기본값 | 설명 |
|--------|------------|------|-----|--------|------|
| NotificationID | INT | NO | PK | IDENTITY | 알림 고유 ID |
| UserID | INT | NO | FK, INDEX | | Users.UserID |
| Type | NVARCHAR(20) | NO | | | 알림 유형 (appointment/reminder/system/promotion) |
| Title | NVARCHAR(100) | NO | | | 알림 제목 |
| Message | NVARCHAR(255) | NO | | | 알림 내용 |
| RelatedID | INT | YES | | | 관련 ID (예약 ID 등) |
| IsRead | BIT | NO | | 0 | 읽음 여부 |
| CreatedAt | DATETIME | NO | INDEX | GETDATE() | 생성 일시 |

**Inquiries (문의 테이블)**

| 컬럼명 | 데이터 타입 | NULL | 키 | 기본값 | 설명 |
|--------|------------|------|-----|--------|------|
| InquiryID | INT | NO | PK | IDENTITY | 문의 고유 ID |
| UserID | INT | YES | FK | | Users.UserID (비회원 가능) |
| Type | NVARCHAR(20) | NO | | | 문의 유형 (general/reservation/technical/suggestion) |
| Name | NVARCHAR(50) | NO | | | 문의자 이름 |
| Email | NVARCHAR(100) | NO | | | 이메일 |
| Phone | NVARCHAR(20) | YES | | | 전화번호 |
| Subject | NVARCHAR(100) | NO | | | 제목 |
| Message | NVARCHAR(1000) | NO | | | 문의 내용 |
| Status | NVARCHAR(20) | NO | | 'pending' | 상태 (pending/answered/closed) |
| AdminReply | NVARCHAR(1000) | YES | | | 관리자 답변 |
| CreatedAt | DATETIME | NO | | GETDATE() | 작성 일시 |
| AnsweredAt | DATETIME | YES | | | 답변 일시 |

#### 2.2.3 저장 프로시저

**sp_GetAvailableTimeSlots (예약 가능 시간 조회)**

```sql
CREATE PROCEDURE sp_GetAvailableTimeSlots
    @DoctorID INT,
    @Date DATE
AS
BEGIN
    SET NOCOUNT ON;
    
    -- 모든 시간 슬롯 (09:00 ~ 18:00, 1시간 단위)
    DECLARE @AllSlots TABLE (TimeSlot TIME);
    
    INSERT INTO @AllSlots VALUES 
        ('09:00'), ('10:00'), ('11:00'), ('12:00'),
        ('13:00'), ('14:00'), ('15:00'), ('16:00'), ('17:00');
    
    -- 이미 예약된 시간 제외
    SELECT TimeSlot
    FROM @AllSlots
    WHERE TimeSlot NOT IN (
        SELECT AppointmentTime
        FROM Appointments
        WHERE DoctorID = @DoctorID
          AND AppointmentDate = @Date
          AND Status IN ('pending', 'approved')
    )
    ORDER BY TimeSlot;
END
```

**sp_CreateAppointment (예약 생성 - 트랜잭션)**

```sql
CREATE PROCEDURE sp_CreateAppointment
    @PatientID INT,
    @DoctorID INT,
    @AppointmentDate DATE,
    @AppointmentTime TIME,
    @Reason NVARCHAR(255),
    @AppointmentID INT OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    BEGIN TRANSACTION;
    
    BEGIN TRY
        -- 1. 중복 예약 확인
        IF EXISTS (
            SELECT 1 FROM Appointments
            WHERE DoctorID = @DoctorID
              AND AppointmentDate = @AppointmentDate
              AND AppointmentTime = @AppointmentTime
              AND Status IN ('pending', 'approved')
        )
        BEGIN
            THROW 50001, '이미 예약된 시간입니다.', 1;
        END
        
        -- 2. 예약 생성
        INSERT INTO Appointments (PatientID, DoctorID, AppointmentDate, AppointmentTime, Reason, Status)
        VALUES (@PatientID, @DoctorID, @AppointmentDate, @AppointmentTime, @Reason, 'pending');
        
        SET @AppointmentID = SCOPE_IDENTITY();
        
        -- 3. 알림 생성
        DECLARE @PatientName NVARCHAR(50);
        SELECT @PatientName = Name FROM Users WHERE UserID = @PatientID;
        
        INSERT INTO Notifications (UserID, Type, Title, Message, RelatedID)
        VALUES (
            @PatientID,
            'appointment',
            '예약이 접수되었습니다',
            CONCAT('예약 날짜: ', FORMAT(@AppointmentDate, 'yyyy-MM-dd'), ' ', FORMAT(@AppointmentTime, 'HH:mm')),
            @AppointmentID
        );
        
        COMMIT TRANSACTION;
    END TRY
    BEGIN CATCH
        ROLLBACK TRANSACTION;
        THROW;
    END CATCH
END
```

**sp_UpdateAppointmentStatus (예약 상태 변경)**

```sql
CREATE PROCEDURE sp_UpdateAppointmentStatus
    @AppointmentID INT,
    @NewStatus NVARCHAR(20)
AS
BEGIN
    SET NOCOUNT ON;
    BEGIN TRANSACTION;
    
    BEGIN TRY
        -- 상태 업데이트
        UPDATE Appointments
        SET Status = @NewStatus, UpdatedAt = GETDATE()
        WHERE AppointmentID = @AppointmentID;
        
        -- 환자에게 알림
        DECLARE @PatientID INT, @Message NVARCHAR(255);
        SELECT @PatientID = PatientID FROM Appointments WHERE AppointmentID = @AppointmentID;
        
        SET @Message = CASE @NewStatus
            WHEN 'approved' THEN '예약이 승인되었습니다.'
            WHEN 'completed' THEN '진료가 완료되었습니다.'
            WHEN 'cancelled' THEN '예약이 취소되었습니다.'
            ELSE '예약 상태가 변경되었습니다.'
        END;
        
        INSERT INTO Notifications (UserID, Type, Title, Message, RelatedID)
        VALUES (@PatientID, 'appointment', '예약 상태 변경', @Message, @AppointmentID);
        
        COMMIT TRANSACTION;
    END TRY
    BEGIN CATCH
        ROLLBACK TRANSACTION;
        THROW;
    END CATCH
END
```

#### 2.2.4 트리거

**tr_UpdateHospitalRating (병원 평균 평점 자동 업데이트)**

```sql
CREATE TRIGGER tr_UpdateHospitalRating
ON Reviews
AFTER INSERT, UPDATE, DELETE
AS
BEGIN
    SET NOCOUNT ON;
    
    -- 영향받은 병원 ID 추출
    DECLARE @HospitalIDs TABLE (HospitalID INT);
    
    INSERT INTO @HospitalIDs
    SELECT DISTINCT HospitalID FROM inserted
    UNION
    SELECT DISTINCT HospitalID FROM deleted;
    
    -- 각 병원의 평균 평점 및 리뷰 수 업데이트
    UPDATE H
    SET 
        H.Rating = ISNULL(AVG(CAST(R.Rating AS DECIMAL(3,2))), 0),
        H.ReviewCount = COUNT(R.ReviewID)
    FROM Hospitals H
    INNER JOIN @HospitalIDs HID ON H.HospitalID = HID.HospitalID
    LEFT JOIN Reviews R ON H.HospitalID = R.HospitalID
    GROUP BY H.HospitalID;
END
```

계속해서 나머지 내용을 작성하겠습니다...

