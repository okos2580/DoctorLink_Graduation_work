# V. 유지보수

## 1. 소스코드 목록

전체 소스코드 목록은 다음과 같습니다.

### 1.1 웹 애플리케이션 (doctorlink)

```
doctorlink/
├── public/
│   ├── index.html                  (SPA 메인 HTML)
│   └── icons/                      (SVG 아이콘 모음)
│
├── src/
│   ├── pages/                      (페이지 컴포넌트, 25개)
│   ├── components/                 (재사용 컴포넌트, 30개 이상)
│   ├── context/AuthContext.tsx     (인증 상태 관리)
│   ├── services/                   (API 서비스, 8개)
│   ├── types/index.ts              (TypeScript 타입 정의)
│   ├── utils/                      (유틸리티 함수)
│   ├── hooks/                      (커스텀 훅)
│   └── App.tsx                     (루트 컴포넌트)
│
├── src/server/                     (백엔드 서버)
│   ├── index.js                    (Express 서버 엔트리)
│   ├── db/index.js                 (DB 연결)
│   ├── middleware/                 (미들웨어 3개)
│   └── routes/api/                 (API 라우터 8개)
│
├── database/                       (DB 스크립트)
│   ├── create_database.sql
│   ├── create_stored_procedures.sql
│   └── insert_sample_data.sql
│
├── package.json
└── README.md
```

### 1.2 모바일 애플리케이션 (DoctorLinkApp)

```
DoctorLinkApp/
├── assets/
│   ├── icon.png                    (앱 아이콘)
│   ├── splash-icon.png             (스플래시 화면)
│   └── adaptive-icon.png           (Android Adaptive Icon)
│
├── src/
│   ├── screens/                    (화면 컴포넌트)
│   │   ├── auth/                   (인증 화면, 2개)
│   │   ├── main/                   (메인 화면, 1개)
│   │   ├── hospital/               (병원 화면, 2개)
│   │   ├── reservation/            (예약 화면, 3개)
│   │   ├── medical/                (진료 기록, 2개)
│   │   ├── profile/                (프로필, 2개)
│   │   ├── notification/           (알림, 1개)
│   │   ├── info/                   (정보 화면, 5개)
│   │   └── admin/                  (관리자, 14개)
│   │
│   ├── navigation/
│   │   └── AppNavigator.tsx        (네비게이션 설정)
│   │
│   ├── contexts/
│   │   └── AuthContext.tsx         (인증 컨텍스트)
│   │
│   ├── services/                   (API 서비스, 4개)
│   ├── components/common/          (공통 컴포넌트)
│   ├── types/index.ts              (타입 정의)
│   ├── styles/theme.ts             (테마 설정)
│   └── utils/                      (유틸리티)
│
├── backend/                        (백엔드 서버 - 웹과 공유)
│   └── src/
│       ├── index.ts
│       ├── config/
│       ├── controllers/
│       ├── routes/
│       ├── services/
│       └── models/
│
├── App.tsx                         (루트 컴포넌트)
├── app.json                        (Expo 설정)
├── package.json
└── README.md
```

### 1.3 주요 소스코드 파일 크기

| 파일 경로 | 라인 수 | 크기 | 설명 |
|-----------|---------|------|------|
| src/screens/main/HomeScreen.tsx | 350 | 12KB | 홈 화면 |
| src/screens/hospital/HospitalFinderScreen.tsx | 420 | 15KB | 병원 검색 |
| src/screens/reservation/ReservationScreen.tsx | 550 | 19KB | 예약하기 |
| src/screens/admin/AdminDashboardScreen.tsx | 380 | 14KB | 관리자 대시보드 |
| src/contexts/AuthContext.tsx | 280 | 10KB | 인증 관리 |
| src/navigation/AppNavigator.tsx | 320 | 11KB | 네비게이션 |
| src/server/index.js | 200 | 7KB | 서버 엔트리 |
| src/server/routes/api/auth.js | 180 | 6KB | 인증 API |
| database/create_database.sql | 250 | 9KB | DB 생성 스크립트 |
| **전체** | **~15,000** | **~500KB** | (node_modules 제외) |

---

# VI. 부록

## 1. 객체지향 프로그래밍 개념

### 1.1 클래스와 객체

TypeScript/JavaScript에서는 인터페이스와 클래스를 통해 객체 모델링을 수행한다.

**인터페이스 정의 (타입 정의)**

```typescript
// 사용자 인터페이스
interface User {
  userId: number;
  email: string;
  name: string;
  phone: string;
  role: 'patient' | 'doctor' | 'admin';
  birthDate?: string;
  gender?: 'male' | 'female';
  createdAt: Date;
}

// 병원 인터페이스
interface Hospital {
  hospitalId: number;
  name: string;
  address: string;
  type: string;
  phone: string;
  latitude: number;
  longitude: number;
  rating: number;
}
```

**객체 생성 예시**

```typescript
const user: User = {
  userId: 1,
  email: "patient@example.com",
  name: "홍길동",
  phone: "010-1234-5678",
  role: "patient",
  birthDate: "1990-01-01",
  gender: "male",
  createdAt: new Date()
};

const hospital: Hospital = {
  hospitalId: 1,
  name: "서울대학교병원",
  address: "서울시 종로구 대학로 101",
  type: "종합병원",
  phone: "02-2072-0505",
  latitude: 37.5798,
  longitude: 127.0015,
  rating: 4.8
};
```

### 1.2 메서드(함수)

함수는 특정 작업을 수행하는 재사용 가능한 코드 블록이다.

**서비스 메서드 예시**

```typescript
// authService.ts
export const login = async (email: string, password: string): Promise<AuthResponse> => {
  const response = await api.post('/auth/login', { email, password });
  return response.data;
};

export const register = async (userData: RegisterRequest): Promise<AuthResponse> => {
  const response = await api.post('/auth/register', userData);
  return response.data;
};

// hospitalService.ts
export const getHospitals = async (filters?: HospitalFilters): Promise<Hospital[]> => {
  const response = await api.get('/hospitals', { params: filters });
  return response.data;
};

export const searchHospitals = async (query: string): Promise<Hospital[]> => {
  const response = await api.get(`/hospitals/search?q=${query}`);
  return response.data;
};
```

### 1.3 캡슐화

캡슐화는 데이터와 메서드를 하나로 묶고, 외부에서의 직접 접근을 제한하는 원칙이다.

**Context API를 통한 캡슐화**

```typescript
export const AuthProvider: React.FC = ({ children }) => {
  // 내부 상태 (외부에서 직접 접근 불가)
  const [user, setUser] = useState<User | null>(null);
  const [token, setToken] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  
  // 공개 메서드 (외부에서 호출 가능)
  const login = async (email: string, password: string) => {
    const response = await authService.login(email, password);
    setUser(response.user);
    setToken(response.token);
    localStorage.setItem('token', response.token);
  };
  
  const logout = async () => {
    await authService.logout();
    setUser(null);
    setToken(null);
    localStorage.removeItem('token');
  };
  
  // Context를 통해 공개 인터페이스만 제공
  return (
    <AuthContext.Provider value={{ user, isLoading, login, logout }}>
      {children}
    </AuthContext.Provider>
  );
};
```

### 1.4 상속

TypeScript에서는 인터페이스 확장과 클래스 상속을 지원한다.

**인터페이스 확장**

```typescript
// 기본 사용자 인터페이스
interface BaseUser {
  userId: number;
  email: string;
  name: string;
  phone: string;
  role: string;
}

// 환자 인터페이스 (BaseUser 상속)
interface Patient extends BaseUser {
  role: 'patient';
  medicalHistory: string[];
  allergies: string[];
  bloodType: string;
}

// 의사 인터페이스 (BaseUser 상속)
interface Doctor extends BaseUser {
  role: 'doctor';
  specialty: string;
  licenseNumber: string;
  hospitalId: number;
}
```

**클래스 상속**

```typescript
// 기본 API 서비스 클래스
abstract class BaseApiService {
  protected baseURL: string;
  
  constructor(baseURL: string) {
    this.baseURL = baseURL;
  }
  
  protected async get<T>(endpoint: string): Promise<T> {
    const response = await fetch(`${this.baseURL}${endpoint}`);
    return response.json();
  }
  
  protected async post<T>(endpoint: string, data: any): Promise<T> {
    const response = await fetch(`${this.baseURL}${endpoint}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data)
    });
    return response.json();
  }
}

// 병원 서비스 (상속)
class HospitalApiService extends BaseApiService {
  constructor() {
    super('/api/hospitals');
  }
  
  async getHospitals(): Promise<Hospital[]> {
    return this.get<Hospital[]>('/');
  }
  
  async searchByCity(city: string): Promise<Hospital[]> {
    return this.get<Hospital[]>(`/search?city=${city}`);
  }
}
```

## 2. 모바일 플랫폼

### 2.1 Android

본 프로젝트는 React Native를 사용하여 Android 플랫폼을 지원한다.

**Android 요구사항**
- Android 10.0 (API 레벨 29) 이상
- 최소 RAM: 2GB
- Google Play Services 필요 (FCM 푸시 알림)

**Android 특화 기능**

**Material Design 3 적용**
```typescript
import { Button, Card, TextInput } from 'react-native-paper';

const theme = {
  colors: {
    primary: '#007AFF',
    secondary: '#34C759',
    background: '#F2F2F7',
    surface: '#FFFFFF',
  },
  roundness: 8,
};
```

**권한 처리**
```typescript
import * as Location from 'expo-location';

const requestLocationPermission = async () => {
  const { status } = await Location.requestForegroundPermissionsAsync();
  if (status === 'granted') {
    const location = await Location.getCurrentPositionAsync({});
    return location;
  }
};
```

**Android 빌드**
```bash
# APK 빌드
expo build:android -t apk

# AAB 빌드 (Google Play)
expo build:android -t app-bundle
```

### 2.2 iOS

iOS 플랫폼도 동일한 React Native 코드베이스로 지원한다.

**iOS 요구사항**
- iOS 13.0 이상
- iPhone 6s 이상, iPad Air 2 이상

**iOS 특화 기능**
- Face ID / Touch ID 생체 인증
- Apple Push Notification Service (APNs)
- iOS 디자인 가이드라인 준수

**iOS 빌드**
```bash
# iOS 빌드 (macOS 필요)
expo build:ios

# 또는 EAS Build
eas build --platform ios
```

## 3. 데이터베이스

### 3.1 SQLite (향후 계획)

현재는 MS SQL Server를 사용하지만, 향후 오프라인 캐싱을 위해 SQLite 도입을 계획 중이다.

**SQLite 도입 목적**
- 오프라인 모드 지원
- 자주 조회하는 데이터 캐싱
- 임시 저장소

**SQLite 사용 예시**

```typescript
import * as SQLite from 'expo-sqlite';

const db = SQLite.openDatabase('doctorlink.db');

// 테이블 생성
db.transaction(tx => {
  tx.executeSql(
    `CREATE TABLE IF NOT EXISTS hospitals (
      id INTEGER PRIMARY KEY,
      name TEXT,
      address TEXT,
      cached_at DATETIME DEFAULT CURRENT_TIMESTAMP
    );`
  );
});

// 데이터 삽입
const cacheHospital = (hospital: Hospital) => {
  db.transaction(tx => {
    tx.executeSql(
      'INSERT OR REPLACE INTO hospitals (id, name, address) VALUES (?, ?, ?)',
      [hospital.hospitalId, hospital.name, hospital.address]
    );
  });
};
```

## 4. API

### 4.1 RESTful API 원칙

본 프로젝트는 RESTful API 아키텍처를 채택하였다.

**HTTP 메서드**

| 메서드 | 용도 | 예시 |
|--------|------|------|
| GET | 조회 | `GET /api/hospitals` |
| POST | 생성 | `POST /api/appointments` |
| PUT | 전체 수정 | `PUT /api/users/1` |
| PATCH | 부분 수정 | `PATCH /api/appointments/1/status` |
| DELETE | 삭제 | `DELETE /api/appointments/1` |

**주요 API 엔드포인트**

**인증 API**
```
POST /api/auth/register       # 회원가입
POST /api/auth/login          # 로그인
POST /api/auth/logout         # 로그아웃
GET  /api/auth/me             # 현재 사용자 정보
```

**병원 API**
```
GET  /api/hospitals                    # 병원 목록
GET  /api/hospitals/:id                # 병원 상세
GET  /api/hospitals/search?q=keyword   # 병원 검색
GET  /api/hospitals/nearby?lat=&lng=   # 근처 병원
```

**예약 API**
```
GET  /api/appointments/availability    # 가능 시간
POST /api/appointments                 # 예약 생성
GET  /api/appointments/patient         # 환자 예약 목록
PUT  /api/appointments/:id             # 예약 수정
DELETE /api/appointments/:id           # 예약 취소
```

### 4.2 JWT 인증

**JWT 토큰 구조**
```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.    # Header
eyJ1c2VySWQiOjEsInJvbGUiOiJwYXRpZW50IiwiaWF0IjoxNzA1...  # Payload
SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c      # Signature
```

**Payload 내용**
```json
{
  "userId": 1,
  "role": "patient",
  "iat": 1705401600,
  "exp": 1706006400
}
```

**API 요청 시 토큰 사용**
```typescript
const config = {
  headers: {
    'Authorization': `Bearer ${token}`,
    'Content-Type': 'application/json'
  }
};

await axios.get('/api/appointments/patient', config);
```

## 5. 외부 API

### 5.1 카카오맵 API

카카오맵 API를 통해 병원 위치 시각화 및 길찾기 기능을 제공한다.

**카카오맵 초기화**

```html
<script src="//dapi.kakao.com/v2/maps/sdk.js?appkey=YOUR_APP_KEY"></script>
```

```typescript
useEffect(() => {
  const container = document.getElementById('map');
  const options = {
    center: new kakao.maps.LatLng(hospital.latitude, hospital.longitude),
    level: 3
  };
  
  const map = new kakao.maps.Map(container, options);
  
  // 마커 추가
  const marker = new kakao.maps.Marker({
    position: new kakao.maps.LatLng(hospital.latitude, hospital.longitude)
  });
  marker.setMap(map);
}, [hospital]);
```

**주소 → 좌표 변환**

```typescript
const getCoordinates = (address: string): Promise<{ lat: number, lng: number }> => {
  return new Promise((resolve, reject) => {
    const geocoder = new kakao.maps.services.Geocoder();
    
    geocoder.addressSearch(address, (result, status) => {
      if (status === kakao.maps.services.Status.OK) {
        resolve({
          lat: parseFloat(result[0].y),
          lng: parseFloat(result[0].x)
        });
      } else {
        reject(new Error('주소 변환 실패'));
      }
    });
  });
};
```

## 6. 참고문헌

[1] Roy Fielding, "Architectural Styles and the Design of Network-based Software Architectures", University of California, Irvine, 2000

[2] Meta Open Source, "React Documentation", https://react.dev, 2024

[3] Meta Open Source, "React Native Documentation", https://reactnative.dev, 2024

[4] Node.js Foundation, "Node.js Documentation", https://nodejs.org/docs, 2024

[5] Microsoft Corporation, "SQL Server Documentation", https://docs.microsoft.com/sql-server, 2024

[6] Microsoft Corporation, "TypeScript Handbook", https://www.typescriptlang.org/docs, 2024

[7] Auth0 Inc., "JWT Handbook", https://auth0.com/resources/ebooks/jwt-handbook, 2023

[8] Mozilla Foundation, "HTTP Protocol Documentation", https://developer.mozilla.org/docs/Web/HTTP, 2024

[9] Google LLC, "Material Design 3", https://m3.material.io, 2024

[10] Kakao Corporation, "Kakao Maps API", https://developers.kakao.com/docs/latest/ko/local/dev-guide, 2024

[11] Expo Inc., "Expo Documentation", https://docs.expo.dev, 2024

[12] OWASP Foundation, "OWASP Top Ten", https://owasp.org/www-project-top-ten, 2024

[13] Martin Fowler, "Patterns of Enterprise Application Architecture", Addison-Wesley, 2002

[14] Robert C. Martin, "Clean Architecture", Prentice Hall, 2017

[15] Eric Evans, "Domain-Driven Design", Addison-Wesley, 2003

---

# VII. 결론

## 1. 프로젝트 성과

본 졸업 프로젝트에서는 웹과 모바일을 아우르는 통합 의료 예약 플랫폼 DoctorLink를 성공적으로 개발하였다.

**주요 성과**
- **웹 애플리케이션**: 30개 이상의 컴포넌트, 25개의 페이지
- **모바일 애플리케이션**: 44개의 화면 컴포넌트
- **백엔드 API**: 20개 이상의 RESTful 엔드포인트
- **데이터베이스**: 정규화된 8개 테이블, 저장 프로시저 구현
- **총 코드량**: 약 15,000 라인 (주석 포함)

## 2. 기술적 의의

**크로스플랫폼 개발**
- React와 React Native의 유사한 개발 경험
- 웹과 모바일이 동일한 API 사용
- TypeScript로 타입 안정성 확보

**확장 가능한 아키텍처**
- 계층형 구조 (Presentation - Business - Data)
- 서비스 레이어 분리
- Context API를 활용한 상태 관리

**보안**
- JWT 기반 인증
- bcrypt 해싱
- SQL Injection, XSS 방어

## 3. 한계점 및 개선 방안

**현재 한계점**
- 실제 결제 시스템 미연동
- 실시간 알림 미완성
- 대용량 트래픽 미검증

**향후 개선 방안**
- Firebase Cloud Messaging 연동
- 결제 시스템 연동 (카카오페이, 토스페이먼츠)
- AWS/Azure 클라우드 마이그레이션
- AI 기반 증상 분석 시스템
- 블록체인 기반 의료 기록 무결성 보장

## 4. 프로젝트 소감

본 프로젝트를 통해 풀스택 개발의 전 과정을 경험하였다. 특히 React와 React Native의 컴포넌트 기반 아키텍처는 코드 재사용성을 높여주었으며, TypeScript는 대규모 프로젝트에서 타입 안정성을 보장하는 데 큰 도움이 되었다.

데이터베이스 설계에서는 정규화를 통해 데이터 무결성을 확보하고, 저장 프로시저를 활용하여 복잡한 비즈니스 로직을 효율적으로 처리하는 방법을 배웠다. 또한 RESTful API 설계 원칙을 준수함으로써 클라이언트와 서버 간의 명확한 계약을 정의할 수 있었다.

보안 측면에서는 JWT 기반 인증, 비밀번호 해싱, 입력 검증 등을 구현하면서 웹 애플리케이션 보안의 기초를 탄탄히 다질 수 있었다.

## 5. 기대 효과

DoctorLink 플랫폼이 실제 서비스로 확장된다면 다음과 같은 긍정적 효과를 기대할 수 있다:

**사회적 효과**
- 의료 서비스 접근성 향상
- 대기 시간 감소
- 노쇼(No-show) 감소

**경제적 효과**
- 병원 운영 효율화
- 환자 편의성 증대
- 의료 산업 디지털 전환 촉진

**기술적 파급 효과**
- 의료 IT 분야의 기술 참고 자료
- 크로스플랫폼 개발 사례 제공

## 6. 맺음말

본 프로젝트는 단순한 졸업 작품을 넘어, 실제 사회 문제를 해결하고자 하는 시도였다. 병원 예약의 불편함이라는 작은 문제에서 출발하여, 환자와 의료진을 연결하는 플랫폼을 구축하였다.

컴퓨터공학도로서, 기술이 사람들의 삶을 더 편리하게 만들 수 있다는 것을 몸소 체험한 의미 있는 프로젝트였다. 앞으로도 이러한 문제 해결 지향적 개발 마인드를 유지하며, 사회에 기여하는 개발자로 성장하고자 한다.

---

# 부록: 핵심 소스코드

## A. 웹 - AuthContext.tsx (인증 관리)

```typescript
import React, { createContext, useContext, useState, useEffect } from 'react';
import * as authService from '../services/authService';
import { User, LoginRequest, RegisterRequest } from '../types';

interface AuthContextType {
  user: User | null;
  isLoading: boolean;
  login: (credentials: LoginRequest) => Promise<void>;
  register: (data: RegisterRequest) => Promise<void>;
  logout: () => Promise<void>;
  updateUser: (data: Partial<User>) => void;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    checkAuthStatus();
  }, []);

  const checkAuthStatus = async () => {
    try {
      const token = localStorage.getItem('token');
      if (token) {
        const userData = await authService.getCurrentUser();
        setUser(userData);
      }
    } catch (error) {
      console.error('Auth check failed:', error);
      localStorage.removeItem('token');
    } finally {
      setIsLoading(false);
    }
  };

  const login = async (credentials: LoginRequest) => {
    const response = await authService.login(credentials);
    localStorage.setItem('token', response.token);
    setUser(response.user);
  };

  const register = async (data: RegisterRequest) => {
    const response = await authService.register(data);
    localStorage.setItem('token', response.token);
    setUser(response.user);
  };

  const logout = async () => {
    await authService.logout();
    localStorage.removeItem('token');
    setUser(null);
  };

  const updateUser = (data: Partial<User>) => {
    if (user) {
      setUser({ ...user, ...data });
    }
  };

  return (
    <AuthContext.Provider value={{ user, isLoading, login, register, logout, updateUser }}>
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider');
  }
  return context;
};
```

## B. 모바일 - AppNavigator.tsx (네비게이션)

```typescript
import React from 'react';
import { NavigationContainer } from '@react-navigation/native';
import { createStackNavigator } from '@react-navigation/stack';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import { Ionicons } from '@expo/vector-icons';
import { useAuth } from '../contexts/AuthContext';

import LoginScreen from '../screens/auth/LoginScreen';
import HomeScreen from '../screens/main/HomeScreen';
import HospitalFinderScreen from '../screens/hospital/HospitalFinderScreen';
import ReservationManagementScreen from '../screens/reservation/ReservationManagementScreen';
import MedicalRecordsScreen from '../screens/medical/MedicalRecordsScreen';
import MyPageScreen from '../screens/profile/MyPageScreen';

const Stack = createStackNavigator();
const Tab = createBottomTabNavigator();

const PatientTabNavigator: React.FC = () => {
  return (
    <Tab.Navigator
      screenOptions={({ route }) => ({
        tabBarIcon: ({ focused, color, size }) => {
          let iconName: keyof typeof Ionicons.glyphMap;
          if (route.name === 'Home') iconName = focused ? 'home' : 'home-outline';
          else if (route.name === 'HospitalFinder') iconName = focused ? 'business' : 'business-outline';
          else if (route.name === 'Reservations') iconName = focused ? 'calendar' : 'calendar-outline';
          else if (route.name === 'MedicalRecords') iconName = focused ? 'document-text' : 'document-text-outline';
          else iconName = focused ? 'person' : 'person-outline';
          return <Ionicons name={iconName} size={size} color={color} />;
        },
        tabBarActiveTintColor: '#007AFF',
        tabBarInactiveTintColor: 'gray',
      })}
    >
      <Tab.Screen name="Home" component={HomeScreen} options={{ tabBarLabel: '홈' }} />
      <Tab.Screen name="HospitalFinder" component={HospitalFinderScreen} options={{ tabBarLabel: '병원찾기' }} />
      <Tab.Screen name="Reservations" component={ReservationManagementScreen} options={{ tabBarLabel: '예약' }} />
      <Tab.Screen name="MedicalRecords" component={MedicalRecordsScreen} options={{ tabBarLabel: '진료기록' }} />
      <Tab.Screen name="MyPage" component={MyPageScreen} options={{ tabBarLabel: '마이' }} />
    </Tab.Navigator>
  );
};

const AppNavigator: React.FC = () => {
  const { user, isLoading } = useAuth();

  if (isLoading) return null;

  return (
    <NavigationContainer>
      {user ? (
        <Stack.Navigator>
          <Stack.Screen name="MainTabs" component={PatientTabNavigator} options={{ headerShown: false }} />
        </Stack.Navigator>
      ) : (
        <Stack.Navigator>
          <Stack.Screen name="Login" component={LoginScreen} />
        </Stack.Navigator>
      )}
    </NavigationContainer>
  );
};

export default AppNavigator;
```

## C. 백엔드 - auth.js (인증 API)

```javascript
const express = require('express');
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
const router = express.Router();
const db = require('../db');

// 회원가입
router.post('/register', async (req, res) => {
  try {
    const { email, password, name, phone, birthDate, gender, role } = req.body;
    
    // 중복 확인
    const existingUser = await db.query('SELECT * FROM Users WHERE Email = ?', [email]);
    if (existingUser.length > 0) {
      return res.status(400).json({ success: false, message: '이미 사용 중인 이메일입니다.' });
    }
    
    // 비밀번호 해싱
    const hashedPassword = await bcrypt.hash(password, 10);
    
    // 사용자 생성
    const result = await db.query(
      'INSERT INTO Users (Email, Password, Name, Phone, BirthDate, Gender, Role) VALUES (?, ?, ?, ?, ?, ?, ?)',
      [email, hashedPassword, name, phone, birthDate, gender, role || 'patient']
    );
    
    const userId = result.insertId;
    
    // JWT 토큰 생성
    const token = jwt.sign({ userId, role: role || 'patient' }, process.env.JWT_SECRET, { expiresIn: '7d' });
    
    res.status(201).json({
      success: true,
      message: '회원가입 완료',
      token,
      user: { userId, email, name, role: role || 'patient' }
    });
  } catch (error) {
    console.error('Register error:', error);
    res.status(500).json({ success: false, message: '서버 오류' });
  }
});

// 로그인
router.post('/login', async (req, res) => {
  try {
    const { email, password } = req.body;
    
    // 사용자 조회
    const users = await db.query('SELECT * FROM Users WHERE Email = ?', [email]);
    if (users.length === 0) {
      return res.status(401).json({ success: false, message: '이메일 또는 비밀번호가 올바르지 않습니다.' });
    }
    
    const user = users[0];
    
    // 비밀번호 확인
    const isValidPassword = await bcrypt.compare(password, user.Password);
    if (!isValidPassword) {
      return res.status(401).json({ success: false, message: '이메일 또는 비밀번호가 올바르지 않습니다.' });
    }
    
    // JWT 토큰 생성
    const token = jwt.sign({ userId: user.UserID, role: user.Role }, process.env.JWT_SECRET, { expiresIn: '7d' });
    
    res.json({
      success: true,
      token,
      user: {
        userId: user.UserID,
        email: user.Email,
        name: user.Name,
        role: user.Role
      }
    });
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({ success: false, message: '서버 오류' });
  }
});

module.exports = router;
```

---

**총 페이지 수: 약 60페이지 (A4 기준, 졸업논문 완성본)**

